# PERFORMANCE-OPTIMIZED DOCKERFILE
# Multi-stage build for production deployment
# Designed to handle 1000+ concurrent users

FROM node:18-alpine AS base

# Set environment variables for optimization
ENV NODE_ENV=production
ENV NODE_OPTIONS="--max-old-space-size=2048 --expose-gc --optimize-for-size"
ENV UV_THREADPOOL_SIZE=32
ENV NPM_CONFIG_LOGLEVEL=warn
ENV NPM_CONFIG_PROGRESS=false

# Install system dependencies and security updates
RUN apk update && apk upgrade && \
    apk add --no-cache \
    dumb-init \
    curl \
    tzdata \
    ca-certificates && \
    rm -rf /var/cache/apk/*

# Create app user for security
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodeapp -u 1001 -G nodejs

# ================================================
# DEPENDENCIES STAGE - Install and cache dependencies
# ================================================
FROM base AS dependencies

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY package-lock.json* ./

# Install dependencies with optimization
RUN npm ci --only=production --silent --no-audit --no-fund && \
    npm cache clean --force && \
    rm -rf ~/.npm

# ================================================
# BUILD STAGE - Prepare application
# ================================================
FROM base AS build

WORKDIR /app

# Copy dependencies from previous stage
COPY --from=dependencies /app/node_modules ./node_modules

# Copy source code
COPY . .

# Create necessary directories
RUN mkdir -p logs backups uploads temp && \
    chown -R nodeapp:nodejs logs backups uploads temp

# Build application (if needed)
# RUN npm run build

# Remove development dependencies and files
RUN npm prune --production && \
    rm -rf .git .gitignore README.md docs tests __tests__ .eslintrc* .prettierrc* jest.config.js

# ================================================
# PRODUCTION STAGE - Final optimized image
# ================================================
FROM base AS production

WORKDIR /app

# Copy built application from build stage
COPY --from=build --chown=nodeapp:nodejs /app ./

# Create additional performance-optimized directories
RUN mkdir -p /app/logs /app/backups /app/uploads /app/temp /app/cache && \
    chown -R nodeapp:nodejs /app

# Install additional performance tools
RUN apk add --no-cache \
    htop \
    iotop \
    procps && \
    rm -rf /var/cache/apk/*

# Copy performance configuration files
COPY --chown=nodeapp:nodejs src/config/performance-optimization.config.js ./src/config/
COPY --chown=nodeapp:nodejs fighter-jet-optimized.js ./
COPY --chown=nodeapp:nodejs scripts/apply-performance-optimizations.js ./scripts/

# Create startup script with performance optimizations
RUN cat > /app/start-production.sh << 'EOF'
#!/bin/sh
set -e

echo "ðŸš€ Starting NXT Level Tech Backend - Performance Optimized"
echo "=================================================="
echo "Node Version: $(node --version)"
echo "Memory Limit: ${NODE_OPTIONS}"
echo "Thread Pool Size: ${UV_THREADPOOL_SIZE}"
echo "Environment: ${NODE_ENV}"
echo "=================================================="

# Apply performance optimizations
echo "ðŸ”§ Applying performance optimizations..."
node scripts/apply-performance-optimizations.js || echo "âš ï¸ Performance optimization script failed, continuing..."

# Start the application
echo "ðŸš€ Starting Fighter Jet Optimized Server..."
exec node fighter-jet-optimized.js
EOF

RUN chmod +x /app/start-production.sh && \
    chown nodeapp:nodejs /app/start-production.sh

# Create health check script
RUN cat > /app/health-check.sh << 'EOF'
#!/bin/sh
# Health check script for production deployment

# Check if main process is running
curl -f http://localhost:4000/health >/dev/null 2>&1 || exit 1

# Check memory usage (fail if > 90% of limit)
MEMORY_USAGE=$(cat /proc/meminfo | grep MemAvailable | awk '{print $2}')
if [ "$MEMORY_USAGE" -lt 200000 ]; then
  echo "âš ï¸ Low memory warning: ${MEMORY_USAGE}KB available"
fi

# Check if Redis is accessible (if configured)
if [ ! -z "$REDIS_URL" ]; then
  timeout 5 sh -c 'echo > /dev/tcp/redis/6379' >/dev/null 2>&1 || echo "âš ï¸ Redis connection issue"
fi

echo "âœ… Health check passed"
exit 0
EOF

RUN chmod +x /app/health-check.sh && \
    chown nodeapp:nodejs /app/health-check.sh

# Configure log rotation
RUN cat > /etc/logrotate.d/nxtdotx << 'EOF'
/app/logs/*.log {
    daily
    missingok
    rotate 7
    compress
    notifempty
    create 0644 nodeapp nodejs
    postrotate
        /bin/kill -USR1 $(cat /app/app.pid 2>/dev/null) 2>/dev/null || true
    endscript
}
EOF

# Set up performance monitoring
RUN cat > /app/monitor-performance.sh << 'EOF'
#!/bin/sh
# Performance monitoring script

while true; do
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    MEMORY=$(cat /proc/meminfo | grep MemAvailable | awk '{print $2}')
    CPU=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    
    echo "[$TIMESTAMP] Memory Available: ${MEMORY}KB, CPU Usage: ${CPU}%"
    
    # Log to file
    echo "[$TIMESTAMP] Memory: ${MEMORY}KB, CPU: ${CPU}%" >> /app/logs/performance.log
    
    sleep 60
done
EOF

RUN chmod +x /app/monitor-performance.sh && \
    chown nodeapp:nodejs /app/monitor-performance.sh

# Expose ports
EXPOSE 4000 4001

# Set up proper signal handling and process management
ENTRYPOINT ["dumb-init", "--"]

# Switch to non-root user
USER nodeapp

# Performance and security settings
ENV NODE_ENV=production
ENV PORT=4000
ENV ANALYTICS_PORT=4001

# Resource limits (these are applied by Docker, but documented here)
# Memory: 2GB limit, 1GB reservation
# CPU: 2.0 limit, 1.0 reservation

# Health check configuration
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD /app/health-check.sh

# Volume mounts for persistence
VOLUME ["/app/logs", "/app/backups", "/app/uploads"]

# Default command
CMD ["/app/start-production.sh"]

# Build metadata
LABEL maintainer="NXT Level Tech <support@nxtdotx.co.za>"
LABEL version="1.0.0"
LABEL description="Performance-optimized backend for handling 1000+ concurrent users"
LABEL build-date="${BUILD_DATE}"
LABEL vcs-ref="${VCS_REF}"

# Performance optimization notes:
# 1. Multi-stage build reduces final image size
# 2. Alpine Linux base for minimal footprint
# 3. Non-root user for security
# 4. Optimized Node.js flags for performance
# 5. Health checks for reliability
# 6. Log rotation for disk space management
# 7. Performance monitoring built-in
# 8. Proper signal handling with dumb-init
# 9. Resource limits documented
# 10. Security updates applied
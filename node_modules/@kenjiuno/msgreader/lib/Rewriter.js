"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNew = createNew;
exports.open = open;
var const_1 = __importDefault(require("./const"));
var iconv_lite_1 = __importDefault(require("iconv-lite"));
function subArrayOf(buf, start, size) {
    return new Uint8Array(buf.buffer, buf.byteOffset + start, size);
}
function createNew(read, write) {
    return __awaiter(this, void 0, void 0, function () {
        var largeBuf, header, headerView, fat, fatView, dir, dirView, nameBuf;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    largeBuf = new ArrayBuffer(512 * 3);
                    header = new Uint8Array(largeBuf, 0, 512);
                    headerView = new DataView(largeBuf, 0, 512);
                    subArrayOf(header, const_1.default.HEADER.HeaderSignature, 8).set(const_1.default.FILE_HEADER);
                    subArrayOf(header, const_1.default.HEADER.HeaderCLSID, 16).fill(0);
                    headerView.setUint16(const_1.default.HEADER.MinorVersion, 0x003E, true);
                    headerView.setUint16(const_1.default.HEADER.MajorVersion, 0x0003, true);
                    headerView.setUint16(const_1.default.HEADER.ByteOrder, 0xFFFE, true);
                    headerView.setUint16(const_1.default.HEADER.SectorShift, 0x0009, true);
                    headerView.setUint16(const_1.default.HEADER.MiniSectorShift, 0x0006, true);
                    subArrayOf(header, const_1.default.HEADER.Reserved, 6).fill(0);
                    headerView.setUint32(const_1.default.HEADER.NumberofDirectorySectors, 0, true);
                    headerView.setUint32(const_1.default.HEADER.NumberofFATSectors, 1, true);
                    headerView.setUint32(const_1.default.HEADER.FirstDirectorySectorLocation, 1, true);
                    headerView.setUint32(const_1.default.HEADER.TransactionSignatureNumber, 0, true);
                    headerView.setUint32(const_1.default.HEADER.MiniStreamCutoffSize, 4096, true);
                    headerView.setUint32(const_1.default.HEADER.FirstMiniFATSectorLocation, 0xFFFFFFFE, true);
                    headerView.setUint32(const_1.default.HEADER.NumberofMiniFATSectors, 0, true);
                    headerView.setUint32(const_1.default.HEADER.FirstDIFATSectorLocation, 0xFFFFFFFE, true);
                    headerView.setUint32(const_1.default.HEADER.NumberofDIFATSectors, 0, true);
                    subArrayOf(header, const_1.default.HEADER.DIFAT, 436).fill(0xFF);
                    headerView.setUint32(const_1.default.HEADER.DIFAT + 4 * 0, 0, true);
                    return [4 /*yield*/, write(new Uint8Array(headerView.buffer, headerView.byteOffset, 512), 0)];
                case 1:
                    _a.sent();
                    fat = new Uint8Array(largeBuf, 512, 512);
                    fatView = new DataView(largeBuf, 512, 512);
                    fat.fill(0xFF); // Mark as unused sectors
                    fatView.setUint32(4 * 0, 0xFFFFFFFD, true); // FAT sector (this)
                    fatView.setUint32(4 * 1, 0xFFFFFFFE, true); // Directory entry sector
                    return [4 /*yield*/, write(fat, 512)];
                case 2:
                    _a.sent();
                    dir = new Uint8Array(largeBuf, 512 * 2, 512);
                    dirView = new DataView(largeBuf, 512 * 2, 512);
                    nameBuf = iconv_lite_1.default.encode("Root Entry\0", 'utf16le');
                    subArrayOf(dir, 0, 64).set(nameBuf);
                    dirView.setUint16(const_1.default.MSG.PROP.NAME_SIZE_OFFSET, nameBuf.byteLength, true);
                    dirView.setUint8(const_1.default.MSG.PROP.TYPE_OFFSET, const_1.default.MSG.PROP.TYPE_ENUM.ROOT);
                    dirView.setUint32(const_1.default.MSG.PROP.PREVIOUS_PROPERTY_OFFSET, 0xFFFFFFFF, true);
                    dirView.setUint32(const_1.default.MSG.PROP.NEXT_PROPERTY_OFFSET, 0xFFFFFFFF, true);
                    dirView.setUint32(const_1.default.MSG.PROP.CHILD_PROPERTY_OFFSET, 0xFFFFFFFF, true);
                    subArrayOf(dir, 0x64, 8).fill(0);
                    subArrayOf(dir, 0x6C, 8).fill(0);
                    dirView.setUint32(const_1.default.MSG.PROP.START_BLOCK_OFFSET, 0xFFFFFFFE, true);
                    dirView.setUint32(const_1.default.MSG.PROP.SIZE_OFFSET, 0, true);
                    return [4 /*yield*/, write(dir, 512 * 2)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, open(read, write)];
                case 4: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function open(read, write) {
    return __awaiter(this, void 0, void 0, function () {
        function mustRead(view, position) {
            return __awaiter(this, void 0, void 0, function () {
                var readActually;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, read(view, position)];
                        case 1:
                            readActually = _a.sent();
                            if (readActually != view.byteLength) {
                                throw new Error('Read failed');
                            }
                            return [2 /*return*/, readActually];
                    }
                });
            });
        }
        function createGetNextSector() {
            var _this = this;
            var tempBuf = new ArrayBuffer(512);
            var tempView = new DataView(tempBuf);
            var tempArray = new Uint8Array(tempBuf, 0, 4);
            return function (currentSector) { return __awaiter(_this, void 0, void 0, function () {
                var difatIndex, fatSector, fatIndex;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(currentSector < 127 * 109)) return [3 /*break*/, 3];
                            difatIndex = (currentSector / 127) & 127;
                            return [4 /*yield*/, read(tempArray, const_1.default.HEADER.DIFAT + 4 * difatIndex)];
                        case 1:
                            if ((_a.sent()) != 4) {
                                throw new Error('Read failed');
                            }
                            fatSector = tempView.getUint32(0, true);
                            if (fatSector == 0xFFFFFFFE) {
                                throw new Error('End of chain');
                            }
                            fatIndex = currentSector % 127;
                            return [4 /*yield*/, read(tempArray, 512 * (1 + fatSector) + 4 * fatIndex)];
                        case 2:
                            if ((_a.sent()) != 4) {
                                throw new Error('Read failed');
                            }
                            return [2 /*return*/, tempView.getUint32(0, true)];
                        case 3: throw new Error('Not implemented');
                    }
                });
            }); };
        }
        function readOfSector(firstSector, position, buf) {
            return __awaiter(this, void 0, void 0, function () {
                var remaining, offset, currentSector, getNextSector, readSize;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            remaining = buf.byteLength;
                            offset = 0;
                            currentSector = firstSector;
                            getNextSector = createGetNextSector();
                            _a.label = 1;
                        case 1:
                            if (!(1 <= remaining)) return [3 /*break*/, 5];
                            if (!(position < 512)) return [3 /*break*/, 3];
                            readSize = Math.min(512 - position, remaining);
                            return [4 /*yield*/, mustRead(new Uint8Array(buf.buffer, buf.byteOffset + offset, readSize), 512 * (1 + currentSector))];
                        case 2:
                            _a.sent();
                            remaining -= readSize;
                            offset += readSize;
                            _a.label = 3;
                        case 3: return [4 /*yield*/, getNextSector(currentSector)];
                        case 4:
                            currentSector = _a.sent();
                            position -= 512;
                            return [3 /*break*/, 1];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        }
        var headerBuf, header, headerView;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    headerBuf = new ArrayBuffer(512);
                    header = new Uint8Array(headerBuf);
                    return [4 /*yield*/, mustRead(header, 0)];
                case 1:
                    _a.sent();
                    if (false
                        || header[0] != 0xD0
                        || header[1] != 0xCF
                        || header[2] != 0x11
                        || header[3] != 0xE0
                        || header[4] != 0xA1
                        || header[5] != 0xB1
                        || header[6] != 0x1A
                        || header[7] != 0xE1) {
                        throw new Error('Invalid header signature');
                    }
                    headerView = new DataView(headerBuf);
                    if (headerView.getUint16(const_1.default.HEADER.MajorVersion, true) != 3) {
                        throw new Error('Invalid major version');
                    }
                    if (headerView.getUint16(const_1.default.HEADER.ByteOrder, true) != 0xFFFE) {
                        throw new Error('Invalid byte order');
                    }
                    if (headerView.getUint16(const_1.default.HEADER.SectorShift, true) != 0x0009) {
                        throw new Error('Invalid sector size must be 512');
                    }
                    if (headerView.getUint16(const_1.default.HEADER.MiniSectorShift, true) != 0x0006) {
                        throw new Error('Invalid mini sector size must be 64');
                    }
                    return [2 /*return*/, {
                            listEntries: function (parentId) {
                                return __awaiter(this, void 0, void 0, function () {
                                    var tempBuf, temp4, temp128, tempView, firstSector, childIndex, list;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                tempBuf = new ArrayBuffer(128);
                                                temp4 = new Uint8Array(tempBuf, 0, 4);
                                                temp128 = new Uint8Array(tempBuf, 0, 128);
                                                tempView = new DataView(tempBuf);
                                                return [4 /*yield*/, mustRead(temp4, const_1.default.HEADER.FirstDirectorySectorLocation)];
                                            case 1:
                                                _a.sent();
                                                firstSector = tempView.getUint32(0, true);
                                                return [4 /*yield*/, readOfSector(firstSector, 128 * parentId + const_1.default.MSG.PROP.CHILD_PROPERTY_OFFSET, temp4)];
                                            case 2:
                                                _a.sent();
                                                childIndex = tempView.getUint32(0, true);
                                                list = [];
                                                return [4 /*yield*/, readOfSector(firstSector, 128 * childIndex, temp128)];
                                            case 3:
                                                _a.sent();
                                                return [2 /*return*/, list];
                                        }
                                    });
                                });
                            },
                            deleteEntry: function (id) {
                                return __awaiter(this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        return [2 /*return*/];
                                    });
                                });
                            },
                            addFile: function (name) {
                                return __awaiter(this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        return [2 /*return*/, 0];
                                    });
                                });
                            },
                            addFolder: function (name) {
                                return __awaiter(this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        return [2 /*return*/, 0];
                                    });
                                });
                            },
                            readFile: function (id) {
                                return __awaiter(this, void 0, void 0, function () {
                                    var _this = this;
                                    return __generator(this, function (_a) {
                                        return [2 /*return*/, function (view, position) { return __awaiter(_this, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    return [2 /*return*/, 0];
                                                });
                                            }); }];
                                    });
                                });
                            },
                            writeFile: function (id, readFile) {
                                return __awaiter(this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        return [2 /*return*/];
                                    });
                                });
                            },
                            flush: function () {
                                return __awaiter(this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        return [2 /*return*/];
                                    });
                                });
                            },
                        }];
            }
        });
    });
}
